#----------------------------------*-sh-*--------------------------------------
# Bash completions for OpenFOAM applications
# Formatted as "complete ... -F _of_APPNAME APPNAME

unset -f _of_filter_opts 2>/dev/null
_of_filter_opts()
{
    local allOpts=$1
    local applied=$2
    for o in ${allOpts}; do
        [ "${applied/$o/}" == "${applied}" ] && echo $o
    done
}

unset -f _of_adiabaticFlameT 2>/dev/null
_of_adiabaticFlameT()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_adiabaticFlameT adiabaticFlameT

unset -f _of_adjointShapeOptimizationFoam 2>/dev/null
_of_adjointShapeOptimizationFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_adjointShapeOptimizationFoam adjointShapeOptimizationFoam

unset -f _of_ansysToFoam 2>/dev/null
_of_ansysToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_ansysToFoam ansysToFoam

unset -f _of_applyBoundaryLayer 2>/dev/null
_of_applyBoundaryLayer()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -ybl "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_applyBoundaryLayer applyBoundaryLayer

unset -f _of_attachMesh 2>/dev/null
_of_attachMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_attachMesh attachMesh

unset -f _of_autoPatch 2>/dev/null
_of_autoPatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_autoPatch autoPatch

unset -f _of_blockMesh 2>/dev/null
_of_blockMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-blockTopology -noClean -noFunctionObjects -sets -srcDoc -doc -help "
    local optsWithArgs="-case -dict -region "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_blockMesh blockMesh

unset -f _of_boundaryFoam 2>/dev/null
_of_boundaryFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_boundaryFoam boundaryFoam

unset -f _of_boxTurb 2>/dev/null
_of_boxTurb()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_boxTurb boxTurb

unset -f _of_buoyantBoussinesqPimpleFoam 2>/dev/null
_of_buoyantBoussinesqPimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_buoyantBoussinesqPimpleFoam buoyantBoussinesqPimpleFoam

unset -f _of_buoyantBoussinesqSimpleFoam 2>/dev/null
_of_buoyantBoussinesqSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_buoyantBoussinesqSimpleFoam buoyantBoussinesqSimpleFoam

unset -f _of_buoyantPimpleFoam 2>/dev/null
_of_buoyantPimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_buoyantPimpleFoam buoyantPimpleFoam

unset -f _of_buoyantSimpleFoam 2>/dev/null
_of_buoyantSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_buoyantSimpleFoam buoyantSimpleFoam

unset -f _of_cavitatingDyMFoam 2>/dev/null
_of_cavitatingDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_cavitatingDyMFoam cavitatingDyMFoam

unset -f _of_cavitatingFoam 2>/dev/null
_of_cavitatingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_cavitatingFoam cavitatingFoam

unset -f _of_cfx4ToFoam 2>/dev/null
_of_cfx4ToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_cfx4ToFoam cfx4ToFoam

unset -f _of_changeDictionary 2>/dev/null
_of_changeDictionary()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -disablePatchGroups -enableFunctionEntries -latestTime -literalRE -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -instance -region -roots -subDict -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_changeDictionary changeDictionary

unset -f _of_checkMesh 2>/dev/null
_of_checkMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-allGeometry -allTopology -constant -latestTime -meshQuality -newTimes -noFunctionObjects -noTopology -noZero -parallel -writeAllFields -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time -writeFields -writeSets "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_checkMesh checkMesh

unset -f _of_chemFoam 2>/dev/null
_of_chemFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_chemFoam chemFoam

unset -f _of_chemkinToFoam 2>/dev/null
_of_chemkinToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-newFormat -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_chemkinToFoam chemkinToFoam

unset -f _of_chtMultiRegionFoam 2>/dev/null
_of_chtMultiRegionFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_chtMultiRegionFoam chtMultiRegionFoam

unset -f _of_chtMultiRegionSimpleFoam 2>/dev/null
_of_chtMultiRegionSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_chtMultiRegionSimpleFoam chtMultiRegionSimpleFoam

unset -f _of_coalChemistryFoam 2>/dev/null
_of_coalChemistryFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_coalChemistryFoam coalChemistryFoam

unset -f _of_coldEngineFoam 2>/dev/null
_of_coldEngineFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_coldEngineFoam coldEngineFoam

unset -f _of_collapseEdges 2>/dev/null
_of_collapseEdges()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-collapseFaces -constant -latestTime -newTimes -noFunctionObjects -noZero -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -collapseFaceSet -decomposeParDict -dict -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_collapseEdges collapseEdges

unset -f _of_combinePatchFaces 2>/dev/null
_of_combinePatchFaces()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-meshQuality -noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -concaveAngle -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_combinePatchFaces combinePatchFaces

unset -f _of_compressibleInterDyMFoam 2>/dev/null
_of_compressibleInterDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_compressibleInterDyMFoam compressibleInterDyMFoam

unset -f _of_compressibleInterFoam 2>/dev/null
_of_compressibleInterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_compressibleInterFoam compressibleInterFoam

unset -f _of_compressibleMultiphaseInterFoam 2>/dev/null
_of_compressibleMultiphaseInterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_compressibleMultiphaseInterFoam compressibleMultiphaseInterFoam

unset -f _of_createBaffles 2>/dev/null
_of_createBaffles()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_createBaffles createBaffles

unset -f _of_createExternalCoupledPatchGeometry 2>/dev/null
_of_createExternalCoupledPatchGeometry()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -commsDir -decomposeParDict -region -regions -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_createExternalCoupledPatchGeometry createExternalCoupledPatchGeometry

unset -f _of_createPatch 2>/dev/null
_of_createPatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -writeObj -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_createPatch createPatch

unset -f _of_createZeroDirectory 2>/dev/null
_of_createZeroDirectory()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -templateDir "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_createZeroDirectory createZeroDirectory

unset -f _of_datToFoam 2>/dev/null
_of_datToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_datToFoam datToFoam

unset -f _of_decomposePar 2>/dev/null
_of_decomposePar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-allRegions -cellDist -constant -copyUniform -copyZero -fields -force -ifRequired -latestTime -newTimes -noFunctionObjects -noSets -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_decomposePar decomposePar

unset -f _of_deformedGeom 2>/dev/null
_of_deformedGeom()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_deformedGeom deformedGeom

unset -f _of_dnsFoam 2>/dev/null
_of_dnsFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_dnsFoam dnsFoam

unset -f _of_DPMDyMFoam 2>/dev/null
_of_DPMDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloudName -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_DPMDyMFoam DPMDyMFoam

unset -f _of_DPMFoam 2>/dev/null
_of_DPMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_DPMFoam DPMFoam

unset -f _of_driftFluxFoam 2>/dev/null
_of_driftFluxFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_driftFluxFoam driftFluxFoam

unset -f _of_dsmcFoam 2>/dev/null
_of_dsmcFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_dsmcFoam dsmcFoam

unset -f _of_dsmcInitialise 2>/dev/null
_of_dsmcInitialise()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_dsmcInitialise dsmcInitialise

unset -f _of_electrostaticFoam 2>/dev/null
_of_electrostaticFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_electrostaticFoam electrostaticFoam

unset -f _of_engineCompRatio 2>/dev/null
_of_engineCompRatio()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_engineCompRatio engineCompRatio

unset -f _of_engineFoam 2>/dev/null
_of_engineFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_engineFoam engineFoam

unset -f _of_engineSwirl 2>/dev/null
_of_engineSwirl()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_engineSwirl engineSwirl

unset -f _of_equilibriumCO 2>/dev/null
_of_equilibriumCO()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_equilibriumCO equilibriumCO

unset -f _of_equilibriumFlameT 2>/dev/null
_of_equilibriumFlameT()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_equilibriumFlameT equilibriumFlameT

unset -f _of_extrude2DMesh 2>/dev/null
_of_extrude2DMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_extrude2DMesh extrude2DMesh

unset -f _of_extrudeMesh 2>/dev/null
_of_extrudeMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_extrudeMesh extrudeMesh

unset -f _of_extrudeToRegionMesh 2>/dev/null
_of_extrudeToRegionMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_extrudeToRegionMesh extrudeToRegionMesh

unset -f _of_faceAgglomerate 2>/dev/null
_of_faceAgglomerate()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_faceAgglomerate faceAgglomerate

unset -f _of_financialFoam 2>/dev/null
_of_financialFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_financialFoam financialFoam

unset -f _of_fireFoam 2>/dev/null
_of_fireFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_fireFoam fireFoam

unset -f _of_fireToFoam 2>/dev/null
_of_fireToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -check -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_fireToFoam fireToFoam

unset -f _of_flattenMesh 2>/dev/null
_of_flattenMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_flattenMesh flattenMesh

unset -f _of_fluent3DMeshToFoam 2>/dev/null
_of_fluent3DMeshToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-cubit -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -ignoreCellGroups -ignoreFaceGroups -scale "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_fluent3DMeshToFoam fluent3DMeshToFoam

unset -f _of_fluentMeshToFoam 2>/dev/null
_of_fluentMeshToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -writeSets -writeZones -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_fluentMeshToFoam fluentMeshToFoam

unset -f _of_foamDataToFluent 2>/dev/null
_of_foamDataToFluent()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-latestTime -newTimes -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamDataToFluent foamDataToFluent

unset -f _of_foamDictionary 2>/dev/null
_of_foamDictionary()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-disableFunctionEntries -expand -includes -keywords -noFunctionObjects -parallel -remove -value -srcDoc -doc -help "
    local optsWithArgs="-add -case -decomposeParDict -diff -entry -roots -set "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamDictionary foamDictionary

unset -f _of_foamFormatConvert 2>/dev/null
_of_foamFormatConvert()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -enableFunctionEntries -latestTime -newTimes -noConstant -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamFormatConvert foamFormatConvert

unset -f _of_foamHelp 2>/dev/null
_of_foamHelp()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamHelp foamHelp

unset -f _of_foamList 2>/dev/null
_of_foamList()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-compressibleTurbulenceModels -functionObjects -fvOptions -incompressibleTurbulenceModels -noFunctionObjects -registeredSwitches -switches -unset -srcDoc -doc -help "
    local optsWithArgs="-case -scalarBCs -vectorBCs "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamList foamList

unset -f _of_foamListTimes 2>/dev/null
_of_foamListTimes()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -processor -rm -withZero -srcDoc -doc -help "
    local optsWithArgs="-case -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamListTimes foamListTimes

unset -f _of_foamMeshToFluent 2>/dev/null
_of_foamMeshToFluent()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamMeshToFluent foamMeshToFluent

unset -f _of_foamToEnsight 2>/dev/null
_of_foamToEnsight()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -constant -latestTime -newTimes -noFunctionObjects -noLagrangian -noPatches -noZero -nodeValues -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -cellZone -decomposeParDict -faceZones -fields -name -patches -region -roots -time -width "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamToEnsight foamToEnsight

unset -f _of_foamToEnsightParts 2>/dev/null
_of_foamToEnsightParts()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -constant -latestTime -newTimes -noFunctionObjects -noLagrangian -noMesh -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -index -name -time -width "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamToEnsightParts foamToEnsightParts

unset -f _of_foamToFireMesh 2>/dev/null
_of_foamToFireMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -constant -latestTime -newTimes -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -scale -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamToFireMesh foamToFireMesh

unset -f _of_foamToGMV 2>/dev/null
_of_foamToGMV()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamToGMV foamToGMV

unset -f _of_foamToStarMesh 2>/dev/null
_of_foamToStarMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noBnd -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -scale -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamToStarMesh foamToStarMesh

unset -f _of_foamToSurface 2>/dev/null
_of_foamToSurface()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -tri -srcDoc -doc -help "
    local optsWithArgs="-case -scale -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamToSurface foamToSurface

unset -f _of_foamToTetDualMesh 2>/dev/null
_of_foamToTetDualMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -noFunctionObjects -noZero -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamToTetDualMesh foamToTetDualMesh

unset -f _of_foamToVTK 2>/dev/null
_of_foamToVTK()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-allPatches -ascii -constant -latestTime -nearCellValue -newTimes -noFaceZones -noFunctionObjects -noInternal -noLagrangian -noLinks -noPointValues -noZero -parallel -poly -surfaceFields -useTimeName -xml -srcDoc -doc -help "
    local optsWithArgs="-case -cellSet -decomposeParDict -excludePatches -faceSet -fields -name -pointSet -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamToVTK foamToVTK

unset -f _of_foamUpgradeCyclics 2>/dev/null
_of_foamUpgradeCyclics()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -enableFunctionEntries -latestTime -newTimes -noFunctionObjects -noZero -parallel -test -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamUpgradeCyclics foamUpgradeCyclics

unset -f _of_foamyHexMesh 2>/dev/null
_of_foamyHexMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-checkGeometry -conformationOnly -noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamyHexMesh foamyHexMesh

unset -f _of_foamyQuadMesh 2>/dev/null
_of_foamyQuadMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case -pointsFile "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_foamyQuadMesh foamyQuadMesh

unset -f _of_gambitToFoam 2>/dev/null
_of_gambitToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_gambitToFoam gambitToFoam

unset -f _of_gmshToFoam 2>/dev/null
_of_gmshToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-keepOrientation -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -region "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_gmshToFoam gmshToFoam

unset -f _of_icoFoam 2>/dev/null
_of_icoFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_icoFoam icoFoam

unset -f _of_icoUncoupledKinematicParcelDyMFoam 2>/dev/null
_of_icoUncoupledKinematicParcelDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_icoUncoupledKinematicParcelDyMFoam icoUncoupledKinematicParcelDyMFoam

unset -f _of_icoUncoupledKinematicParcelFoam 2>/dev/null
_of_icoUncoupledKinematicParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_icoUncoupledKinematicParcelFoam icoUncoupledKinematicParcelFoam

unset -f _of_ideasUnvToFoam 2>/dev/null
_of_ideasUnvToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-dump -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_ideasUnvToFoam ideasUnvToFoam

unset -f _of_insideCells 2>/dev/null
_of_insideCells()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_insideCells insideCells

unset -f _of_interCondensatingEvaporatingFoam 2>/dev/null
_of_interCondensatingEvaporatingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_interCondensatingEvaporatingFoam interCondensatingEvaporatingFoam

unset -f _of_interDyMFoam 2>/dev/null
_of_interDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_interDyMFoam interDyMFoam

unset -f _of_interFoam 2>/dev/null
_of_interFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_interFoam interFoam

unset -f _of_interIsoFoam 2>/dev/null
_of_interIsoFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_interIsoFoam interIsoFoam

unset -f _of_interMixingFoam 2>/dev/null
_of_interMixingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_interMixingFoam interMixingFoam

unset -f _of_interPhaseChangeDyMFoam 2>/dev/null
_of_interPhaseChangeDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_interPhaseChangeDyMFoam interPhaseChangeDyMFoam

unset -f _of_interPhaseChangeFoam 2>/dev/null
_of_interPhaseChangeFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_interPhaseChangeFoam interPhaseChangeFoam

unset -f _of_kivaToFoam 2>/dev/null
_of_kivaToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -file -version -zHeadMin "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_kivaToFoam kivaToFoam

unset -f _of_laplacianFoam 2>/dev/null
_of_laplacianFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_laplacianFoam laplacianFoam

unset -f _of_lumpedPointForces 2>/dev/null
_of_lumpedPointForces()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noZero -parallel -vtk -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_lumpedPointForces lumpedPointForces

unset -f _of_lumpedPointMovement 2>/dev/null
_of_lumpedPointMovement()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-removeLock -slave -srcDoc -doc -help "
    local optsWithArgs="-case -max -scale -span "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_lumpedPointMovement lumpedPointMovement

unset -f _of_lumpedPointZones 2>/dev/null
_of_lumpedPointZones()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-verbose -srcDoc -doc -help "
    local optsWithArgs="-case -region "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_lumpedPointZones lumpedPointZones

unset -f _of_magneticFoam 2>/dev/null
_of_magneticFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noB -noFunctionObjects -noH -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_magneticFoam magneticFoam

unset -f _of_mapFields 2>/dev/null
_of_mapFields()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-consistent -noFunctionObjects -parallelSource -parallelTarget -subtract -srcDoc -doc -help "
    local optsWithArgs="-case -mapMethod -sourceDecomposeParDict -sourceRegion -sourceTime -targetDecomposeParDict -targetRegion "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_mapFields mapFields

unset -f _of_mapFieldsPar 2>/dev/null
_of_mapFieldsPar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-consistent -noFunctionObjects -noLagrangian -parallel -subtract -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -fields -mapMethod -patchMapMethod -roots -sourceRegion -sourceTime -targetRegion "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_mapFieldsPar mapFieldsPar

unset -f _of_mdEquilibrationFoam 2>/dev/null
_of_mdEquilibrationFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_mdEquilibrationFoam mdEquilibrationFoam

unset -f _of_mdFoam 2>/dev/null
_of_mdFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_mdFoam mdFoam

unset -f _of_mdInitialise 2>/dev/null
_of_mdInitialise()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_mdInitialise mdInitialise

unset -f _of_mergeMeshes 2>/dev/null
_of_mergeMeshes()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-addRegion -case -decomposeParDict -masterRegion -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_mergeMeshes mergeMeshes

unset -f _of_mergeOrSplitBaffles 2>/dev/null
_of_mergeOrSplitBaffles()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-detectOnly -noFunctionObjects -overwrite -parallel -split -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_mergeOrSplitBaffles mergeOrSplitBaffles

unset -f _of_mhdFoam 2>/dev/null
_of_mhdFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_mhdFoam mhdFoam

unset -f _of_mirrorMesh 2>/dev/null
_of_mirrorMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_mirrorMesh mirrorMesh

unset -f _of_mixtureAdiabaticFlameT 2>/dev/null
_of_mixtureAdiabaticFlameT()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_mixtureAdiabaticFlameT mixtureAdiabaticFlameT

unset -f _of_modifyMesh 2>/dev/null
_of_modifyMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_modifyMesh modifyMesh

unset -f _of_moveDynamicMesh 2>/dev/null
_of_moveDynamicMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-checkAMI -noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_moveDynamicMesh moveDynamicMesh

unset -f _of_moveEngineMesh 2>/dev/null
_of_moveEngineMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_moveEngineMesh moveEngineMesh

unset -f _of_moveMesh 2>/dev/null
_of_moveMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_moveMesh moveMesh

unset -f _of_MPPICDyMFoam 2>/dev/null
_of_MPPICDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloudName -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_MPPICDyMFoam MPPICDyMFoam

unset -f _of_MPPICFoam 2>/dev/null
_of_MPPICFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_MPPICFoam MPPICFoam

unset -f _of_MPPICInterFoam 2>/dev/null
_of_MPPICInterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_MPPICInterFoam MPPICInterFoam

unset -f _of_mshToFoam 2>/dev/null
_of_mshToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-hex -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_mshToFoam mshToFoam

unset -f _of_multiphaseEulerFoam 2>/dev/null
_of_multiphaseEulerFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_multiphaseEulerFoam multiphaseEulerFoam

unset -f _of_multiphaseInterDyMFoam 2>/dev/null
_of_multiphaseInterDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_multiphaseInterDyMFoam multiphaseInterDyMFoam

unset -f _of_multiphaseInterFoam 2>/dev/null
_of_multiphaseInterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_multiphaseInterFoam multiphaseInterFoam

unset -f _of_netgenNeutralToFoam 2>/dev/null
_of_netgenNeutralToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_netgenNeutralToFoam netgenNeutralToFoam

unset -f _of_noise 2>/dev/null
_of_noise()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_noise noise

unset -f _of_nonNewtonianIcoFoam 2>/dev/null
_of_nonNewtonianIcoFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_nonNewtonianIcoFoam nonNewtonianIcoFoam

unset -f _of_objToVTK 2>/dev/null
_of_objToVTK()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_objToVTK objToVTK

unset -f _of_orientFaceZone 2>/dev/null
_of_orientFaceZone()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_orientFaceZone orientFaceZone

unset -f _of_overInterDyMFoam 2>/dev/null
_of_overInterDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_overInterDyMFoam overInterDyMFoam

unset -f _of_overLaplacianDyMFoam 2>/dev/null
_of_overLaplacianDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_overLaplacianDyMFoam overLaplacianDyMFoam

unset -f _of_overPimpleDyMFoam 2>/dev/null
_of_overPimpleDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_overPimpleDyMFoam overPimpleDyMFoam

unset -f _of_overRhoPimpleDyMFoam 2>/dev/null
_of_overRhoPimpleDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_overRhoPimpleDyMFoam overRhoPimpleDyMFoam

unset -f _of_overSimpleFoam 2>/dev/null
_of_overSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_overSimpleFoam overSimpleFoam

unset -f _of_particleTracks 2>/dev/null
_of_particleTracks()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_particleTracks particleTracks

unset -f _of_patchSummary 2>/dev/null
_of_patchSummary()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -expand -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_patchSummary patchSummary

unset -f _of_pdfPlot 2>/dev/null
_of_pdfPlot()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_pdfPlot pdfPlot

unset -f _of_PDRFoam 2>/dev/null
_of_PDRFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_PDRFoam PDRFoam

unset -f _of_PDRMesh 2>/dev/null
_of_PDRMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_PDRMesh PDRMesh

unset -f _of_pimpleDyMFoam 2>/dev/null
_of_pimpleDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_pimpleDyMFoam pimpleDyMFoam

unset -f _of_pimpleFoam 2>/dev/null
_of_pimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_pimpleFoam pimpleFoam

unset -f _of_pisoFoam 2>/dev/null
_of_pisoFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_pisoFoam pisoFoam

unset -f _of_plot3dToFoam 2>/dev/null
_of_plot3dToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noBlank -noFunctionObjects -singleBlock -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_plot3dToFoam plot3dToFoam

unset -f _of_polyDualMesh 2>/dev/null
_of_polyDualMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-concaveMultiCells -doNotPreserveFaceZones -noFunctionObjects -overwrite -splitAllFaces -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_polyDualMesh polyDualMesh

unset -f _of_porousSimpleFoam 2>/dev/null
_of_porousSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_porousSimpleFoam porousSimpleFoam

unset -f _of_postChannel 2>/dev/null
_of_postChannel()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_postChannel postChannel

unset -f _of_postProcess 2>/dev/null
_of_postProcess()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -list -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -field -fields -func -funcs -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_postProcess postProcess

unset -f _of_potentialFoam 2>/dev/null
_of_potentialFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-initialiseUBCs -noFunctionObjects -parallel -withFunctionObjects -writePhi -writep -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -pName -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_potentialFoam potentialFoam

unset -f _of_potentialFreeSurfaceDyMFoam 2>/dev/null
_of_potentialFreeSurfaceDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_potentialFreeSurfaceDyMFoam potentialFreeSurfaceDyMFoam

unset -f _of_potentialFreeSurfaceFoam 2>/dev/null
_of_potentialFreeSurfaceFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_potentialFreeSurfaceFoam potentialFreeSurfaceFoam

unset -f _of_reactingFoam 2>/dev/null
_of_reactingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_reactingFoam reactingFoam

unset -f _of_reactingMultiphaseEulerFoam 2>/dev/null
_of_reactingMultiphaseEulerFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_reactingMultiphaseEulerFoam reactingMultiphaseEulerFoam

unset -f _of_reactingParcelFilmFoam 2>/dev/null
_of_reactingParcelFilmFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_reactingParcelFilmFoam reactingParcelFilmFoam

unset -f _of_reactingParcelFoam 2>/dev/null
_of_reactingParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_reactingParcelFoam reactingParcelFoam

unset -f _of_reactingTwoPhaseEulerFoam 2>/dev/null
_of_reactingTwoPhaseEulerFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_reactingTwoPhaseEulerFoam reactingTwoPhaseEulerFoam

unset -f _of_reconstructPar 2>/dev/null
_of_reconstructPar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-allRegions -constant -latestTime -newTimes -noFields -noFunctionObjects -noLagrangian -noSets -noZero -withZero -srcDoc -doc -help "
    local optsWithArgs="-case -fields -lagrangianFields -region -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_reconstructPar reconstructPar

unset -f _of_reconstructParMesh 2>/dev/null
_of_reconstructParMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-cellDist -constant -fullMatch -latestTime -newTimes -noFunctionObjects -noZero -withZero -srcDoc -doc -help "
    local optsWithArgs="-case -mergeTol -region -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_reconstructParMesh reconstructParMesh

unset -f _of_redistributePar 2>/dev/null
_of_redistributePar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-cellDist -constant -decompose -latestTime -newTimes -noFunctionObjects -noZero -overwrite -parallel -reconstruct -withZero -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -mergeTol -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_redistributePar redistributePar

unset -f _of_refineHexMesh 2>/dev/null
_of_refineHexMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-minSet -noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_refineHexMesh refineHexMesh

unset -f _of_refinementLevel 2>/dev/null
_of_refinementLevel()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -readLevel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_refinementLevel refinementLevel

unset -f _of_refineMesh 2>/dev/null
_of_refineMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-all -noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_refineMesh refineMesh

unset -f _of_refineWallLayer 2>/dev/null
_of_refineWallLayer()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -useSet "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_refineWallLayer refineWallLayer

unset -f _of_removeFaces 2>/dev/null
_of_removeFaces()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_removeFaces removeFaces

unset -f _of_renumberMesh 2>/dev/null
_of_renumberMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -frontWidth -latestTime -noFunctionObjects -noZero -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_renumberMesh renumberMesh

unset -f _of_rhoCentralDyMFoam 2>/dev/null
_of_rhoCentralDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_rhoCentralDyMFoam rhoCentralDyMFoam

unset -f _of_rhoCentralFoam 2>/dev/null
_of_rhoCentralFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_rhoCentralFoam rhoCentralFoam

unset -f _of_rhoPimpleDyMFoam 2>/dev/null
_of_rhoPimpleDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_rhoPimpleDyMFoam rhoPimpleDyMFoam

unset -f _of_rhoPimpleFoam 2>/dev/null
_of_rhoPimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_rhoPimpleFoam rhoPimpleFoam

unset -f _of_rhoPorousSimpleFoam 2>/dev/null
_of_rhoPorousSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_rhoPorousSimpleFoam rhoPorousSimpleFoam

unset -f _of_rhoReactingBuoyantFoam 2>/dev/null
_of_rhoReactingBuoyantFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_rhoReactingBuoyantFoam rhoReactingBuoyantFoam

unset -f _of_rhoReactingFoam 2>/dev/null
_of_rhoReactingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_rhoReactingFoam rhoReactingFoam

unset -f _of_rhoSimpleFoam 2>/dev/null
_of_rhoSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_rhoSimpleFoam rhoSimpleFoam

unset -f _of_rotateMesh 2>/dev/null
_of_rotateMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_rotateMesh rotateMesh

unset -f _of_scalarTransportFoam 2>/dev/null
_of_scalarTransportFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_scalarTransportFoam scalarTransportFoam

unset -f _of_selectCells 2>/dev/null
_of_selectCells()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_selectCells selectCells

unset -f _of_setAlphaField 2>/dev/null
_of_setAlphaField()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_setAlphaField setAlphaField

unset -f _of_setFields 2>/dev/null
_of_setFields()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_setFields setFields

unset -f _of_setSet 2>/dev/null
_of_setSet()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -loop -newTimes -noFunctionObjects -noSync -noVTK -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-batch -case -decomposeParDict -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_setSet setSet

unset -f _of_setsToZones 2>/dev/null
_of_setsToZones()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFlipMap -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_setsToZones setsToZones

unset -f _of_shallowWaterFoam 2>/dev/null
_of_shallowWaterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_shallowWaterFoam shallowWaterFoam

unset -f _of_simpleCoalParcelFoam 2>/dev/null
_of_simpleCoalParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_simpleCoalParcelFoam simpleCoalParcelFoam

unset -f _of_simpleFoam 2>/dev/null
_of_simpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_simpleFoam simpleFoam

unset -f _of_simpleReactingParcelFoam 2>/dev/null
_of_simpleReactingParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_simpleReactingParcelFoam simpleReactingParcelFoam

unset -f _of_singleCellMesh 2>/dev/null
_of_singleCellMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_singleCellMesh singleCellMesh

unset -f _of_smapToFoam 2>/dev/null
_of_smapToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_smapToFoam smapToFoam

unset -f _of_snappyHexMesh 2>/dev/null
_of_snappyHexMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-checkGeometry -noFunctionObjects -overwrite -parallel -profiling -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -outFile -patches -region -roots -surfaceSimplify "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_snappyHexMesh snappyHexMesh

unset -f _of_snappyRefineMesh 2>/dev/null
_of_snappyRefineMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_snappyRefineMesh snappyRefineMesh

unset -f _of_solidDisplacementFoam 2>/dev/null
_of_solidDisplacementFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_solidDisplacementFoam solidDisplacementFoam

unset -f _of_solidEquilibriumDisplacementFoam 2>/dev/null
_of_solidEquilibriumDisplacementFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_solidEquilibriumDisplacementFoam solidEquilibriumDisplacementFoam

unset -f _of_sonicDyMFoam 2>/dev/null
_of_sonicDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_sonicDyMFoam sonicDyMFoam

unset -f _of_sonicFoam 2>/dev/null
_of_sonicFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_sonicFoam sonicFoam

unset -f _of_sonicLiquidFoam 2>/dev/null
_of_sonicLiquidFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_sonicLiquidFoam sonicLiquidFoam

unset -f _of_splitCells 2>/dev/null
_of_splitCells()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-geometry -noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case -set -tol "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_splitCells splitCells

unset -f _of_splitMesh 2>/dev/null
_of_splitMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_splitMesh splitMesh

unset -f _of_splitMeshRegions 2>/dev/null
_of_splitMeshRegions()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-cellZones -cellZonesOnly -detectOnly -largestOnly -makeCellZones -noFunctionObjects -overwrite -parallel -prefixRegion -sloppyCellZones -useFaceZones -srcDoc -doc -help "
    local optsWithArgs="-blockedFaces -case -cellZonesFileOnly -decomposeParDict -insidePoint -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_splitMeshRegions splitMeshRegions

unset -f _of_sprayDyMFoam 2>/dev/null
_of_sprayDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_sprayDyMFoam sprayDyMFoam

unset -f _of_sprayEngineFoam 2>/dev/null
_of_sprayEngineFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_sprayEngineFoam sprayEngineFoam

unset -f _of_sprayFoam 2>/dev/null
_of_sprayFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_sprayFoam sprayFoam

unset -f _of_SRFPimpleFoam 2>/dev/null
_of_SRFPimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_SRFPimpleFoam SRFPimpleFoam

unset -f _of_SRFSimpleFoam 2>/dev/null
_of_SRFSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_SRFSimpleFoam SRFSimpleFoam

unset -f _of_star4ToFoam 2>/dev/null
_of_star4ToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -noFunctionObjects -solids -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_star4ToFoam star4ToFoam

unset -f _of_steadyParticleTracks 2>/dev/null
_of_steadyParticleTracks()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -dict -region -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_steadyParticleTracks steadyParticleTracks

unset -f _of_stitchMesh 2>/dev/null
_of_stitchMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -partial -perfect -srcDoc -doc -help "
    local optsWithArgs="-case -region -toleranceDict "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_stitchMesh stitchMesh

unset -f _of_subsetMesh 2>/dev/null
_of_subsetMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -patch -patches -region -resultTime -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_subsetMesh subsetMesh

unset -f _of_surfaceAdd 2>/dev/null
_of_surfaceAdd()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-mergeRegions -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -points "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceAdd surfaceAdd

unset -f _of_surfaceBooleanFeatures 2>/dev/null
_of_surfaceBooleanFeatures()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-invertedSpace -noFunctionObjects -perturb -surf1Baffle -surf2Baffle -srcDoc -doc -help "
    local optsWithArgs="-case -trim "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceBooleanFeatures surfaceBooleanFeatures

unset -f _of_surfaceCheck 2>/dev/null
_of_surfaceCheck()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-blockMesh -checkSelfIntersection -noFunctionObjects -splitNonManifold -verbose -srcDoc -doc -help "
    local optsWithArgs="-case -outputThreshold "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceCheck surfaceCheck

unset -f _of_surfaceClean 2>/dev/null
_of_surfaceClean()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noClean -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceClean surfaceClean

unset -f _of_surfaceCoarsen 2>/dev/null
_of_surfaceCoarsen()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceCoarsen surfaceCoarsen

unset -f _of_surfaceConvert 2>/dev/null
_of_surfaceConvert()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -group -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale -writePrecision "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceConvert surfaceConvert

unset -f _of_surfaceFeatureConvert 2>/dev/null
_of_surfaceFeatureConvert()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceFeatureConvert surfaceFeatureConvert

unset -f _of_surfaceFeatureExtract 2>/dev/null
_of_surfaceFeatureExtract()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case -dict "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceFeatureExtract surfaceFeatureExtract

unset -f _of_surfaceFind 2>/dev/null
_of_surfaceFind()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -x -y -z "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceFind surfaceFind

unset -f _of_surfaceHookUp 2>/dev/null
_of_surfaceHookUp()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -dict "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceHookUp surfaceHookUp

unset -f _of_surfaceInertia 2>/dev/null
_of_surfaceInertia()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -shellProperties -srcDoc -doc -help "
    local optsWithArgs="-case -density -referencePoint "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceInertia surfaceInertia

unset -f _of_surfaceInflate 2>/dev/null
_of_surfaceInflate()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-checkSelfIntersection -debug -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -featureAngle -nSmooth "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceInflate surfaceInflate

unset -f _of_surfaceLambdaMuSmooth 2>/dev/null
_of_surfaceLambdaMuSmooth()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-featureFile "

    case ${prev} in

    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceLambdaMuSmooth surfaceLambdaMuSmooth

unset -f _of_surfaceMeshConvert 2>/dev/null
_of_surfaceMeshConvert()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -noFunctionObjects -tri -srcDoc -doc -help "
    local optsWithArgs="-case -dict -from -scaleIn -scaleOut -to "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceMeshConvert surfaceMeshConvert

unset -f _of_surfaceMeshConvertTesting 2>/dev/null
_of_surfaceMeshConvertTesting()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -noFunctionObjects -orient -stdout -surfMesh -testModify -triFace -triSurface -unsorted -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceMeshConvertTesting surfaceMeshConvertTesting

unset -f _of_surfaceMeshExport 2>/dev/null
_of_surfaceMeshExport()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -dict -from -name -scaleIn -scaleOut -to "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceMeshExport surfaceMeshExport

unset -f _of_surfaceMeshImport 2>/dev/null
_of_surfaceMeshImport()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -dict -from -name -scaleIn -scaleOut -to "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceMeshImport surfaceMeshImport

unset -f _of_surfaceMeshInfo 2>/dev/null
_of_surfaceMeshInfo()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-areas -noFunctionObjects -xml -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceMeshInfo surfaceMeshInfo

unset -f _of_surfaceMeshTriangulate 2>/dev/null
_of_surfaceMeshTriangulate()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -excludeProcPatches -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -faceZones -patches -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceMeshTriangulate surfaceMeshTriangulate

unset -f _of_surfaceOrient 2>/dev/null
_of_surfaceOrient()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-inside -noFunctionObjects -usePierceTest -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceOrient surfaceOrient

unset -f _of_surfacePatch 2>/dev/null
_of_surfacePatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -dict "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfacePatch surfacePatch

unset -f _of_surfacePointMerge 2>/dev/null
_of_surfacePointMerge()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfacePointMerge surfacePointMerge

unset -f _of_surfaceRedistributePar 2>/dev/null
_of_surfaceRedistributePar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-keepNonMapped -noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceRedistributePar surfaceRedistributePar

unset -f _of_surfaceRefineRedGreen 2>/dev/null
_of_surfaceRefineRedGreen()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceRefineRedGreen surfaceRefineRedGreen

unset -f _of_surfaceSplitByPatch 2>/dev/null
_of_surfaceSplitByPatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceSplitByPatch surfaceSplitByPatch

unset -f _of_surfaceSplitByTopology 2>/dev/null
_of_surfaceSplitByTopology()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs=" "

    case ${prev} in

    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceSplitByTopology surfaceSplitByTopology

unset -f _of_surfaceSplitNonManifolds 2>/dev/null
_of_surfaceSplitNonManifolds()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-debug -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceSplitNonManifolds surfaceSplitNonManifolds

unset -f _of_surfaceSubset 2>/dev/null
_of_surfaceSubset()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceSubset surfaceSubset

unset -f _of_surfaceToPatch 2>/dev/null
_of_surfaceToPatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -faceSet -tol "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceToPatch surfaceToPatch

unset -f _of_surfaceTransformPoints 2>/dev/null
_of_surfaceTransformPoints()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -rollPitchYaw -rotate -scale -translate -yawPitchRoll "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_surfaceTransformPoints surfaceTransformPoints

unset -f _of_temporalInterpolate 2>/dev/null
_of_temporalInterpolate()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -divisions -fields -interpolationType -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_temporalInterpolate temporalInterpolate

unset -f _of_tetgenToFoam 2>/dev/null
_of_tetgenToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFaceFile -noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_tetgenToFoam tetgenToFoam

unset -f _of_thermoFoam 2>/dev/null
_of_thermoFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_thermoFoam thermoFoam

unset -f _of_topoSet 2>/dev/null
_of_topoSet()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noSync -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_topoSet topoSet

unset -f _of_transformPoints 2>/dev/null
_of_transformPoints()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -rotateFields -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -rollPitchYaw -roots -rotate -scale -translate -yawPitchRoll "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_transformPoints transformPoints

unset -f _of_twoLiquidMixingFoam 2>/dev/null
_of_twoLiquidMixingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_twoLiquidMixingFoam twoLiquidMixingFoam

unset -f _of_twoPhaseEulerFoam 2>/dev/null
_of_twoPhaseEulerFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_twoPhaseEulerFoam twoPhaseEulerFoam

unset -f _of_uncoupledKinematicParcelFoam 2>/dev/null
_of_uncoupledKinematicParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_uncoupledKinematicParcelFoam uncoupledKinematicParcelFoam

unset -f _of_viewFactorsGen 2>/dev/null
_of_viewFactorsGen()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_viewFactorsGen viewFactorsGen

unset -f _of_vtkUnstructuredToFoam 2>/dev/null
_of_vtkUnstructuredToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_vtkUnstructuredToFoam vtkUnstructuredToFoam

unset -f _of_wallFunctionTable 2>/dev/null
_of_wallFunctionTable()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_wallFunctionTable wallFunctionTable

unset -f _of_writeMeshObj 2>/dev/null
_of_writeMeshObj()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -patchEdges -patchFaces -srcDoc -doc -help "
    local optsWithArgs="-case -cell -cellSet -decomposeParDict -face -faceSet -point -region -roots -time "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    -time)
        COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_writeMeshObj writeMeshObj

unset -f _of_XiDyMFoam 2>/dev/null
_of_XiDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_XiDyMFoam XiDyMFoam

unset -f _of_XiFoam 2>/dev/null
_of_XiFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_XiFoam XiFoam

unset -f _of_zipUpMesh 2>/dev/null
_of_zipUpMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
    -case)
        COMPREPLY=($(compgen -d -- ${cur}))
        ;;
    *Dict)
        COMPREPLY=($(compgen -f -- ${cur}))
        ;;
    -region)
        local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
        COMPREPLY=($(compgen -W "$regions" -- ${cur}))
        ;;
    *)
        if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]
        then
            # Unknown type of arg follows - set to files.
            # Not always correct but can still navigate path if needed...
            COMPREPLY=($(compgen -f -- ${cur}))
        else
            # Catch-all - present all remaining options
            opts=$(_of_filter_opts "${opts}" "${COMP_LINE}")
            optsWithArgs=$(_of_filter_opts "${optsWithArgs}" "${COMP_LINE}")
            COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
        fi
        ;;
    esac

    return 0
}
complete -o nospace -F _of_zipUpMesh zipUpMesh


#------------------------------------------------------------------------------
